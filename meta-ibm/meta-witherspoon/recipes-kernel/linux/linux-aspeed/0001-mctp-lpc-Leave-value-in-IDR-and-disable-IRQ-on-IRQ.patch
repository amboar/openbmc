From 30ff2398bec0886fc191632da1fadf569b7de938 Mon Sep 17 00:00:00 2001
From: Andrew Jeffery <andrew@aj.id.au>
Date: Mon, 13 May 2019 15:58:15 +0930
Subject: [PATCH] mctp-lpc: Leave value in IDR and disable IRQ on IRQ

Re-enable the IRQ when userspace reads the value out.

Signed-off-by: Andrew Jeffery <andrew@aj.id.au>
---
 drivers/misc/mctp-lpc.c | 118 +++++++++++++++++++++-------------------
 1 file changed, 63 insertions(+), 55 deletions(-)

diff --git a/drivers/misc/mctp-lpc.c b/drivers/misc/mctp-lpc.c
index cfa5f99ffa58..cf2ee0d2a62c 100644
--- a/drivers/misc/mctp-lpc.c
+++ b/drivers/misc/mctp-lpc.c
@@ -18,11 +18,6 @@
 #include <linux/uaccess.h>
 #include <linux/wait.h>
 
-#define HOST_ODR             0xca2
-#define HOST_STR             0xca3
-#define HOST_SERIRQ_ID       11
-#define HOST_SERIRQ_TYPE     0
-
 #define LPC_HICRB            0x080
 #define     LPC_HICRB_IBFIF4         BIT(1)
 #define     LPC_HICRB_LPC4E          BIT(0)
@@ -31,6 +26,10 @@
 #define     LPC_KCS4_IRQSEL_SHIFT    4
 #define     LPC_KCS4_IRQTYPE_MASK    GENMASK(3, 2)
 #define     LPC_KCS4_IRQTYPE_SHIFT   2
+#define     LPC_KCS4_IRQTYPE_LOW     0b00
+#define     LPC_KCS4_IRQTYPE_HIGH    0b01
+#define     LPC_KCS4_IRQTYPE_RSVD    0b10
+#define     LPC_KCS4_IRQTYPE_RISING  0b11
 #define     LPC_KCS4_OBF4_AUTO_CLR   BIT(1)
 #define     LPC_KCS4_IRQ_HOST	     BIT(0)
 #define LPC_LADR4            0x090
@@ -40,6 +39,11 @@
 #define     STR4_IBF	     (1 << 1)
 #define     STR4_OBF	     (1 << 0)
 
+#define HOST_ODR             0xca2
+#define HOST_STR             0xca3
+#define HOST_SERIRQ_ID       11
+#define HOST_SERIRQ_TYPE     LPC_KCS4_IRQTYPE_LOW
+
 #define RX_BUF_SIZE 1024
 
 struct mctp_lpc {
@@ -47,40 +51,36 @@ struct mctp_lpc {
 	struct regmap *map;
 
 	wait_queue_head_t rx;
-	u8 idr;
-	u8 str;
+	bool pending;
 };
 
 static irqreturn_t mctp_lpc_irq(int irq, void *data)
 {
 	struct mctp_lpc *priv = data;
 	unsigned long flags;
-	unsigned int idr;
+	unsigned int hicrb;
 	unsigned int str;
+	irqreturn_t ret;
 
 	spin_lock_irqsave(&priv->rx.lock, flags);
 
 	regmap_read(priv->map, LPC_STR4, &str);
-
-	if (!(str & STR4_IBF)) {
-		spin_unlock_irqrestore(&priv->rx.lock, flags);
-		return IRQ_NONE;
-	}
-
-	if (priv->str & STR4_IBF)
-		dev_err(priv->miscdev.parent,
-			"Buffer overrun: dropping idr=0x%x\n", priv->idr);
-
-	/* Have to read IDR to ack IRQ */
-	regmap_read(priv->map, LPC_IDR4, &idr);
-	priv->idr = idr & 0xff;
-	priv->str = str & 0xff;
-
-	wake_up_locked(&priv->rx);
+	regmap_read(priv->map, LPC_HICRB, &hicrb);
+
+	if ((str & STR4_IBF) && (hicrb & LPC_HICRB_IBFIF4)) {
+		if (priv->pending)
+			dev_err(priv->miscdev.this_device, "Storm brewing!");
+		/* Mask the IRQ / Enter polling mode */
+		regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_IBFIF4, 0);
+		priv->pending = true;
+		wake_up_locked(&priv->rx);
+		ret = IRQ_HANDLED;
+	} else
+		ret = IRQ_NONE;
 
 	spin_unlock_irqrestore(&priv->rx.lock, flags);
 
-	return IRQ_HANDLED;
+	return ret;
 }
 
 static inline struct mctp_lpc *to_mctp_lpc(struct file *filp)
@@ -105,8 +105,11 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 
 	spin_lock_irq(&priv->rx.lock);
 	if (*ppos == 0) {
+		unsigned int val;
+		u8 idr;
+
 		/* YOLO blocking, non-block not supported */
-		rc = wait_event_interruptible_locked(priv->rx, (priv->str & STR4_IBF));
+		rc = wait_event_interruptible_locked(priv->rx, priv->pending);
 		if (rc < 0)
 			goto out;
 
@@ -115,7 +118,15 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 			goto out;
 		}
 
-		if (copy_to_user(buf, &priv->idr, sizeof(priv->idr))) {
+		regmap_read(priv->map, LPC_IDR4, &val);
+		idr = val & 0xff;
+
+		priv->pending = false;
+		/* Re-enable IRQs */
+		regmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_IBFIF4,
+				   LPC_HICRB_IBFIF4);
+
+		if (copy_to_user(buf, &idr, sizeof(idr))) {
 			rc = -EFAULT;
 			goto out;
 		}
@@ -131,14 +142,10 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 		 * 2. (count == 2 && *ppos == 0)
 		 */
 		unsigned int val;
-		uint8_t str;
+		u8 str;
 
-		if (priv->str & STR4_IBF) {
-			str = priv->str;
-		} else {
-			regmap_read(priv->map, LPC_STR4, &val);
-			str = val & 0xff;
-		}
+		regmap_read(priv->map, LPC_STR4, &val);
+		str = val & 0xff;
 
 		if (copy_to_user(buf, &str, sizeof(str))) {
 			rc = -EFAULT;
@@ -148,9 +155,6 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 		remaining--;
 	}
 
-	if (*ppos == 0)
-		priv->str &= ~STR4_IBF;
-
 	WARN_ON(remaining);
 
 	rc = count;
@@ -164,11 +168,15 @@ static ssize_t mctp_lpc_read(struct file *filp, char __user *buf,
 static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
 			      size_t count, loff_t *ppos)
 {
-	struct mctp_lpc *priv = to_mctp_lpc(filp);
 	uint8_t _data[2], *data = &_data[0];
+	struct mctp_lpc *priv;
+	struct device *dev;
 	size_t remaining;
 	unsigned int str;
 
+	priv = to_mctp_lpc(filp);
+	dev = priv->miscdev.this_device;
+
 	if (!count)
 		return count;
 
@@ -178,6 +186,9 @@ static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
 	if (*ppos >= 2)
 		return -EINVAL;
 
+	if (*ppos + count > 2)
+		return -EINVAL;
+
 	if (copy_from_user(data, buf, count))
 		return -EFAULT;
 
@@ -186,36 +197,33 @@ static ssize_t mctp_lpc_write(struct file *filp, const char __user *buf,
 	if (*ppos == 0) {
 		/* Wait until OBF is clear - we don't get an IRQ */
 		for (;;) {
-			regmap_read(priv->map, LPC_STR4, &str);
-			if (!(str & STR4_OBF)) {
-				regmap_write(priv->map, LPC_ODR4, *data);
-				remaining--;
-				data++;
-				break;
-			}
-
 			if (signal_pending(current))
 				return -EINTR;
 
+			regmap_read(priv->map, LPC_STR4, &str);
+			if (!(str & STR4_OBF))
+				break;
+
 			msleep(1);
 		}
+
+		regmap_write(priv->map, LPC_ODR4, *data);
+		remaining--;
+		data++;
 	}
 
 	if (remaining) {
-		spin_lock_irq(&priv->rx.lock);
-		/* Maintain the pretence that IBF is set if necessary */
-		priv->str = *data | (priv->str & STR4_IBF);
-		WARN(!(*data & STR4_OBF), "Clearing OBF with status write\n");
+		if (!(*data & STR4_OBF))
+			dev_err(dev, "Clearing OBF with status write: 0x%x\n",
+				*data);
 		regmap_write(priv->map, LPC_STR4, *data);
-		spin_unlock_irq(&priv->rx.lock);
 		remaining--;
 	}
 
 	WARN_ON(remaining);
 
 	regmap_read(priv->map, LPC_STR4, &str);
-	printk("%s:%s:%d: Triggering SerIRQ. STR: 0x%x\n", __FILE__,
-	       __func__, __LINE__, str);
+	dev_dbg(dev, "Triggering SerIRQ. STR: 0x%x\n", str);
 	/* Trigger Host IRQ */
 	regmap_update_bits(priv->map, LPC_HICRC, LPC_KCS4_IRQ_HOST,
 			   LPC_KCS4_IRQ_HOST);
@@ -229,7 +237,7 @@ static __poll_t mctp_lpc_poll(struct file *filp, poll_table *wait)
 	bool ibf;
 
 	spin_lock_irq(&priv->rx.lock);
-	ibf = priv->str & STR4_IBF;
+	ibf = priv->pending;
 	spin_unlock_irq(&priv->rx.lock);
 
 	if (ibf)
@@ -241,7 +249,7 @@ static __poll_t mctp_lpc_poll(struct file *filp, poll_table *wait)
 		return -EINTR;
 
 	spin_lock_irq(&priv->rx.lock);
-	ibf = priv->str & STR4_IBF;
+	ibf = priv->pending;
 	spin_unlock_irq(&priv->rx.lock);
 
 	return ibf ? EPOLLIN : 0;
-- 
2.20.1

